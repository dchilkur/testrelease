import{dirname as f,join as E,relative as v,resolve as k}from"path";import{promises as l}from"fs";import D from"fast-glob";import{analyze as T}from"toposource";import O from"js-yaml";var d=["dependencies","devDependencies","peerDependencies","optionalDependencies"],b=async e=>{let{pkgFilter:s}=e,t=await J(e),o=await Promise.all(t.map(async a=>{let r=f(a),n=v(e.cwd,r),i=await l.readFile(a,"utf8"),c=JSON.parse(i);return{name:c.name,manifestRaw:i,manifestPath:a,manifest:c,path:n,relPath:n,absPath:r}}));return R(o),o.reduce((a,r)=>(s(r)&&(a[r.name]=r),a),{})},R=e=>{let s=e.map(t=>t.name).filter((t,o,a)=>a.indexOf(t)!==o);if(s.length>0)throw new Error(`Duplicated pkg names: ${s.join(", ")}`)},F=async e=>{let s=k(e,"package.json"),t=await l.readFile(s,"utf8"),o=JSON.parse(t);return{name:o.name,manifest:o,manifestPath:s,manifestRaw:t,path:"/",relPath:"/",absPath:f(s)}},N=async(e={})=>{let{cwd:s=process.cwd(),filter:t=m=>!0,pkgFilter:o=t,depFilter:a=m=>!0,workspaces:r,workspacesExtra:n=[]}=e,i=await F(s),c={cwd:s,filter:t,depFilter:a,pkgFilter:o,workspacesExtra:n,workspaces:[...r||await j(i),...n]},g=await b(c),{edges:p,nodes:u}=z(Object.values(g).map(m=>m.manifest),a),{queue:y,graphs:w,next:I,prev:h,sources:x}=T([...p,...u.map(m=>[m])]);return{nodes:u,edges:p,queue:y,graphs:w,sources:x,prev:h,next:I,packages:g,root:i}},j=async e=>(Array.isArray(e.manifest.workspaces)?e.manifest.workspaces:e.manifest.workspaces?.packages)||e.manifest.bolt?.workspaces||await(async()=>{try{let s=k(e.absPath,"pnpm-workspace.yaml");return O.load(await l.readFile(s,"utf8")).packages}catch{return null}})()||[],z=(e,s,t=d)=>{let o=e.map(({name:r})=>r).sort();return{edges:e.reduce((r,n)=>{let i=new Set;return P(n,({name:c,version:g,scope:p})=>{!i.has(c)&&o.includes(c)&&s({name:c,version:g,scope:p})&&(i.add(c),r.push([c,n.name]))},t),r},[]).sort(),nodes:o}},J=async({workspaces:e,cwd:s})=>await D(e.map(t=>S(E(t,"package.json"))),{cwd:s,onlyFiles:!0,absolute:!0}),S=e=>{let s=/^\\\\\?\\/.test(e),t=/[^\u0000-\u0080]+/.test(e);return s||t?e:e.replace(/\\/g,"/")},q=async({queue:e,prev:s,cb:t})=>{let o={};return Promise.all(e.map(a=>o[a]=(async()=>{await Promise.all((s.get(a)||[]).map(r=>o[r])),await t(a)})()))},A=async({packages:e,pkg:s,scopes:t=d,cb:o})=>{let{manifest:a}=s,r=[];P(a,({name:n,version:i,scope:c,deps:g})=>{let p=e[n];p&&r.push(Promise.resolve(o({name:n,version:i,scope:c,deps:g,pkg:p,parent:s})))},t),await Promise.all(r)},P=(e,s,t=d)=>{for(let o of t){let a=e[o];if(a)for(let[r,n]of Object.entries(a))s({name:r,version:n,deps:a,scope:o})}};export{N as topo,A as traverseDeps,q as traverseQueue};
//# sourceMappingURL=index.mjs.map
